# P109: Pack consecutive duplicates of list elements into sublists

打包連續重復的元素為子列表。
要養成良好的習慣，先寫測試用例：

[include](../../tests/lists/p109_test.py)

然後就不知道怎麼辦了？記住！

>沒有什麼問題是遞歸解決不了的！

先假定已經拥有了一個打包方法，其可以將列表中連續重復的元素打包成子列表。然後，將列表拆分為第一個元素和剩餘列表。再然後厭將剩餘列表中連續重復的元素打包成子列表。最後，將拆分出來的第一個元素拼入打包後的剩餘列表。如果第一個元素和打包後的剩餘列表中第一個子列表中的元素相同，則將第一個元素打包進第一個子列表。否則，第一個元素以獨立的子列表拼入剩餘列表。打包方法會持續拆分剩餘列表，直至其為僅包含一個元素的列表。

舉個例子，給定列表`[1, 1, 2, 3, 3, 4]`：

1.
2.
3.

```puml
digraph d {
    s0 [shape=none, label=""]
    l0 [shape=record, label="1|1|2|3|3|4", style=filled, fillcolor=orange]
    s0 -> l0 [style=invis]
    {rank=same; s0,l0}
    s1 [shape=none, label="1)"]
    a1 [shape=box, label=1]
    l1 [shape=record, label="1|2|3|3|4", style=filled, fillcolor=orange]
    s1 -> a1 -> l1 [style=invis]
    {rank=same; s1,a1,l1}
    s2 [shape=none, label="2)"]
    a2 [shape=box, label=1]
    b2 [shape=box, label=1]
    l2 [shape=record, label="2|3|3|4", style=filled, fillcolor=orange]
    s2 -> a2 -> b2 -> l2 [style=invis]
    {rank=same; s2,a2,b2,l2}
    s3 [shape=none, label="3)"]
    a3 [shape=box, label=1]
    b3 [shape=box, label=1]
    c3 [shape=box, label=2]
    l3 [shape=record, label="3|3|4", style=filled, fillcolor=orange]
    s3 -> a3 -> b3 -> c3 -> l3 [style=invis]
    {rank=same; s3,a3,b3,c3,l3}
    s4 [shape=none, label="4)"]
    a4 [shape=box, label=1]
    b4 [shape=box, label=1]
    c4 [shape=box, label=2]
    d4 [shape=box, label=3]
    l4 [shape=record, label="3|4", style=filled, fillcolor=orange]
    s4 -> a4 -> b4 -> c4 -> d4 -> l4 [style=invis]
    {rank=same; s4,a4,b4,c4,d4,l4}
    s0 -> s1 -> s2 -> s3 -> s4 -> s5 -> s6 [style=invis]
}
```

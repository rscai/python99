# Construct minimal spanning tree

## 題目

>Write a predicate ms_tree(Graph,Tree,Sum) to construct the minimal spanning tree of a given labelled graph. Hint: Use the algorithm of Prim. A small modification of the solution of 6.04 does the trick. The data of the example graph to the right can be found in the file p6_05.dat.

### 最小生成樹

>最小生成樹是一副連通加權無向圖中一棵權值最小的生成樹。
>
>在一給定的無向圖 G = (V, E) 中，(u, v) 代表連接頂點 u 與頂點 v 的邊（即 $$ (u,v)\in E）$$，而 w(u, v) 代表此邊的權重，若存在 T 為 E 的子集（即 $$ T\subseteq E）$$ 且 (V, T) 為樹，使得

$$
w(T) = \sum_{(u,v)\subseteq T}^{} w(u,v)
$$

>的 w(T) 最小，則此 T 為 G 的最小生成樹。
>
>最小生成樹其實是最小權重生成樹的簡稱。
>
>一個連通圖可能有多個生成樹。當圖中的邊具有權值時，總會有一個生成樹的邊的權值之和小於或者等於其它生成樹的邊的權值之和。廣義上而言，對於非連通無向圖來說，它的每一連通分量同樣有最小生成樹，它們的並被稱為最小生成森林。

#### 存在個數

>最小生成樹在一些情況下可能會有多個。例如，當圖的每一條邊的權值都相同時，該圖的所有生成樹都是最小生成樹。
>
>如果圖的每一條邊的權值都互不相同，那麼最小生成樹將只有一個。這一定理同樣適用於最小生成森林。
>
>證明（圖的每一條邊的權值皆不相同）：
>
>1. 假設有兩個最小生成樹 $$A$$ 和 $$B$$。
>2. 由於 $$A$$ 和 $$B$$ 是兩個不同的最小生成樹，那麼 $$A$$ 中總會有一個或者多個邊並不在 $$B$$ 中，設這些邊中權值最低的那一條邊為 $$e_{k}$$。
>3. 由於 $$B$$ 是一個最小生成樹，由樹的一些定理可知 $${\displaystyle e_{k}\cup B}$$ 必然包含一個環 $$C$$。
>4. 因為環 $$C$$ 中存在一條邊 $$e_{m}$$ 它的權值比 $$e_{k}$$ 。
>5. 因此用 $$e_{k}$$ 替代 $$e_{m}$$， $$B$$ 成為了一個擁有更小權值的生成樹。這和 $$B$$ 是最小生成樹相矛盾，所以不可能存在兩個最小生成樹。

## 解題思路

>以下各演算法介紹中， $$E$$ 表示圖的邊數， $$V$$ 表示圖的頂點數。　

### Prim演算法

>普林演算法（Prim's algorithm），圖論中的一種演算法，可在加權連通圖里搜索最小生成樹。意即由此演算法搜索到的邊子集所構成的樹中，不但包括了連通圖裡的所有頂點，且其所有邊的權值之和亦為最小。該演算法於1930年由捷克數學家沃伊捷赫·亞爾尼克發現；並在1957年由美國計算機科學家羅伯特·普林獨立發現；1959年，艾茲格·迪科斯徹再次發現了該演算法。因此，在某些場合，普林演算法又被稱為DJP演算法、亞爾尼克演算法或普林－亞爾尼克演算法。
>
>從單一頂點開始，普林演算法按照以下步驟逐步擴大樹中所含頂點的數目，直到遍及連通圖的所有頂點。
>
>1. 輸入：一個加權連通圖，其中頂點集合為V，邊集合為E；
>2. 初始化：$$V_{new} = \{x\}$$，其中x為集合V中的任一節點（起始點），$$E_{new} = \{\}$$；
>3. 重複下列操作，直到$$V_{new} = V$$：
>    1. 在集合E中選取權值最小的邊（u, v），其中u為集合$$V_{new}$$ 中的元素，而v則是V中沒有加入$$V_{new}$$的頂點（如果存在有多條滿足前述條件即具有相同權值的邊，則可任意選取其中之一）；
>    2. 將v加入集合$$V_{new}$$中，將（u, v）加入集合 $$ E_{new} $$ 中；
>4. 輸出：使用集合$$V_{new}$$和$$E_{new}$$來描述所得到的最小生成樹。

舉個例子，給定如下加權無向圖：

```plantuml
graph g {
    a -- b [label=5]
    a -- d [label=3]
    b -- c [label=2]    
    b -- e [label=4]
    c -- e [label=6]
    d -- e [label=7]
    d -- g [label=3]
    d -- f [label=4]
    e -- h [label=5]
    f -- g [label=4]
    g -- h [label=1]


    {rank=same; a, b, c}
    {rank=same; d, e}
    {rank=same; f, g, h}
}
```

* 初始化$$V_{new} = \{a\}$$
* 執行下列操作，直到$$V_{new} = V$$：
    * 選取與$$\{a\}$$相鄰邊且另一端點不在$$\{a\}$$中且權重最小的$$(a, d)$$，將$$b$$加入$$V_{new}$$中得到$$\{a, d\}$$，並將$$(a, d)$$加入$$E_{new}$$中
    * 選取與$$\{a, d\}$$相鄰且另一端點不在$$\{a, d\}$$中且權重最小的邊$$(d, g)$$，將$$g$$加入$$V_{new}$$中得到$$\{a, d, g\}$$，並將$$(d, g)$$加入$$E_{new}$$中
    * 選取與$$\{a, d, g\}$$相鄰且另一端點不在$$\{a, d, g\}$$中且權重最小的邊$$(g, h)$$，將$$h$$加入$$V_{new}$$中得到$$\{a, d, g, h\}$$，並將$$(g, h)$$加入$$E_{new}$$中
    * 選取與$$\{a, d, g, h\}$$相鄰且另一端點不在$$\{a, d, g, h\}$$中且權重最小的邊$$(d, f)$$，將$$f$$加入$$V_{new}$$中得到$$\{a, d, g, h, f\}$$，並將$$(d, f)$$加入$$E_{new}$$中
    * ...
* 將$$V_{new}$$和$$E_{new}$$組合在一起就是一棵最小生成樹

## 代碼實現

[include](../../../python99/graph/p605.py)

{% include "../stdlibrary/functools/reduce.md" %}

## 參考

* [最小生成樹](https://zh.wikipedia.org/wiki/最小生成樹)
* [Borůvka's algorithm](https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm)
* [普林演算法](https://zh.wikipedia.org/wiki/普林演算法)
* [克魯斯克爾演算法](https://zh.wikipedia.org/wiki/克魯斯克爾演算法)